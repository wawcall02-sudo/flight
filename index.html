<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>íƒ„ë§‰ ìŠˆíŒ… ê²Œì„</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(#000, #010a16);
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: linear-gradient(to bottom, #001020, #000);
  }
  #ui {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-family: Arial, sans-serif;
    font-size: 18px;
    display: flex;
    justify-content: space-between;
    width: 90%;
    max-width: 480px;
  }
</style>
</head>
<body>
<canvas id="game" width="460" height="700"></canvas>
<div id="ui">
  <div id="score">Score: 0</div>
  <div id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let mouseX = canvas.width / 2;
let mouseY = canvas.height - 60;

let player = {
  x: mouseX,
  y: mouseY,
  size: 15,
  hp: 3,
  powerLevel: 0,
  bullets: [],
  canShoot: true
};

let enemies = [];
let enemyBullets = [];
let powerups = [];
let boss = null;

let score = 0;
let highScore = 0;
let spawnInterval = 100 * 0.5;  
let enemyBulletCount = 3 * 1.4;  // íƒ„ë§‰ ìˆ˜ 20% ì¦ê°€
let enemyBulletSize = player.size * 0.5; 
let bossSpawnScore = 5000;
let bossHpBase = 1000;

let lastSpawn = 0;
let frame = 0;
let gameOver = false;

canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  player.x = e.clientX - rect.left;
  player.y = e.clientY - rect.top;
});

function shoot() {
  if (!player.canShoot) return;
  let bullets = [];
  if (player.powerLevel === 0) {
    bullets.push({x: player.x, y: player.y - 20, dy: -6});
  } else if (player.powerLevel === 1) {
    bullets.push({x: player.x - 10, y: player.y - 20, dy: -6});
    bullets.push({x: player.x + 10, y: player.y - 20, dy: -6});
  } else {
    bullets.push({x: player.x - 10, y: player.y - 20, dy: -6});
    bullets.push({x: player.x + 10, y: player.y - 20, dy: -6});
    // 2íšŒ ë°œì‚¬
    setTimeout(() => {
      player.bullets.push({x: player.x - 10, y: player.y - 20, dy: -6});
      player.bullets.push({x: player.x + 10, y: player.y - 20, dy: -6});
    }, 100);
  }
  player.bullets.push(...bullets);
  player.canShoot = false;
  setTimeout(() => (player.canShoot = true), 150);
}

function spawnEnemy() {
  enemies.push({
    x: Math.random() * (canvas.width - 20) + 10,
    y: -20,
    hp: Math.random() < 0.5 ? 1 : 2,
    cooldown: 0
  });
}

function spawnPowerup() {
  powerups.push({x: Math.random() * (canvas.width - 20) + 10, y: -10});
}

function drawTriangle(x, y, size, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x, y - size);
  ctx.lineTo(x - size, y + size);
  ctx.lineTo(x + size, y + size);
  ctx.closePath();
  ctx.fill();
}

function loop() {
  if (gameOver) return;

  frame++;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // ì  ì¶œí˜„
  if (frame - lastSpawn > spawnInterval) {
    spawnEnemy();
    lastSpawn = frame;
  }

  // íŒŒì›Œì—… ì¶œí˜„
  if (Math.random() < 0.002) spawnPowerup();

  // í”Œë ˆì´ì–´ ì´ì•Œ
  player.bullets.forEach((b, i) => {
    b.y += b.dy;
    ctx.fillStyle = "cyan";
    ctx.fillRect(b.x - 2, b.y - 10, 4, 10);
    if (b.y < 0) player.bullets.splice(i, 1);
  });

  // ì 
  enemies.forEach((e, i) => {
    e.y += 2;
    drawTriangle(e.x, e.y, 10, "red");

    // ì‚´ì•„ ìˆì„ ë•Œ íƒ„ë§‰ ë°œì‚¬ (ê¸°ì¡´ë³´ë‹¤ 25% ê°ì†Œ)
    if (e.cooldown <= 0 && Math.random() < 0.02) {
      for (let a = 0; a < enemyBulletCount; a++) {
        const angle = (a / enemyBulletCount) * Math.PI * 2;
        enemyBullets.push({
          x: e.x,
          y: e.y,
          dx: Math.cos(angle) * 2,
          dy: Math.sin(angle) * 2,
          size: enemyBulletSize
        });
      }
      e.cooldown = 60;
    } else e.cooldown--;

    // í”¼ê²© íŒì •
    player.bullets.forEach((b, j) => {
      if (Math.abs(b.x - e.x) < 10 && Math.abs(b.y - e.y) < 10) {
        e.hp--;
        player.bullets.splice(j, 1);
        if (e.hp <= 0) {
          enemies.splice(i, 1);
          score += 100;
        }
      }
    });

    if (e.y > canvas.height + 20) enemies.splice(i, 1);
  });

  // ì  ì´ì•Œ
  enemyBullets.forEach((b, i) => {
    b.x += b.dx;
    b.y += b.dy;
    ctx.fillStyle = "orange";
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();
    if (b.y > canvas.height || b.y < 0) enemyBullets.splice(i, 1);
    if (Math.abs(b.x - player.x) < b.size + player.size && Math.abs(b.y - player.y) < b.size + player.size) {
      enemyBullets.splice(i, 1);
      player.hp--;
      updateHearts();
      if (player.hp <= 0) endGame();
    }
  });

  // íŒŒì›Œì—…
  powerups.forEach((p, i) => {
    p.y += 2;
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
    ctx.fill();
    if (Math.abs(p.x - player.x) < 15 && Math.abs(p.y - player.y) < 15) {
      powerups.splice(i, 1);
      player.powerLevel = Math.min(player.powerLevel + 1, 2);
    }
  });

  // í”Œë ˆì´ì–´
  drawTriangle(player.x, player.y, player.size, "white");

  // ì ìˆ˜ / ë³´ìŠ¤ ê´€ë¦¬
  if (!boss && score >= bossSpawnScore) spawnBoss();

  // ë³´ìŠ¤ ì¡´ì¬ ì‹œ
  if (boss) updateBoss();

  document.getElementById("score").innerText = "Score: " + score;

  requestAnimationFrame(loop);
}

function spawnBoss() {
  boss = {x: canvas.width / 2, y: 80, hp: bossHpBase};
}

function updateBoss() {
  ctx.fillStyle = "purple";
  ctx.fillRect(boss.x - 40, boss.y - 20, 80, 40);
  ctx.fillStyle = "red";
  ctx.fillRect(boss.x - 40, boss.y - 30, (boss.hp / bossHpBase) * 80, 5);

  if (Math.random() < 0.05) {
    for (let a = 0; a < 16; a++) {
      const angle = (a / 16) * Math.PI * 2;
      enemyBullets.push({
        x: boss.x,
        y: boss.y,
        dx: Math.cos(angle) * 3,
        dy: Math.sin(angle) * 3,
        size: enemyBulletSize * 1.5
      });
    }
  }

  player.bullets.forEach((b, j) => {
    if (Math.abs(b.x - boss.x) < 40 && Math.abs(b.y - boss.y) < 40) {
      boss.hp -= 10;
      player.bullets.splice(j, 1);
      if (boss.hp <= 0) {
        score += 2000;
        boss = null;
        bossSpawnScore += 10000;
        bossHpBase *= 2; // ì²´ë ¥ 2ë°° ì¦ê°€
        spawnInterval *= 0.9;
        enemyBulletCount *= 1.1;
      }
    }
  });
}

function updateHearts() {
  const heartDisplay = "â¤ï¸".repeat(player.hp) + "ğŸ–¤".repeat(3 - player.hp);
  document.getElementById("lives").innerText = heartDisplay;
}

function endGame() {
  gameOver = true;
  alert("ê²Œì„ ì˜¤ë²„! ì ìˆ˜: " + score);
}

setInterval(shoot, 200);
loop();
</script>
</body>
</html>
