<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>탄막 슈팅 게임</title>
<style>
  body { margin: 0; overflow: hidden; background: radial-gradient(#000, #010a16); }
  canvas { display: block; margin: 0 auto; background: linear-gradient(to bottom, #001020, #000); }
  #ui { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: white; font-family: Arial, sans-serif; font-size: 18px; display: flex; justify-content: space-between; width: 90%; max-width: 480px; }
</style>
</head>
<body>
<canvas id="game" width="460" height="700"></canvas>
<div id="ui">
  <div id="score">Score: 0</div>
  <div id="lives">❤️❤️❤️</div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let mouseX = canvas.width / 2;
let mouseY = canvas.height - 60;

let player = {
  x: mouseX,
  y: mouseY,
  size: 15,
  hp: 3,
  powerLevel: 0,
  bullets: [],
  canShoot: true
};

let enemies = [];
let enemyBullets = [];
let powerups = [];
let boss = null;

let score = 0;
let highScore = 0;
let spawnInterval = 100 * 0.8;  // 적 출현 빈도 25% 증가
let enemyBulletCount = 3 * 1.2; // 탄막 수 20% 증가
let enemyBulletSize = player.size * 0.5; 
let bossSpawnScore = 5000;
let bossHpBase = 1000;

let lastSpawn = 0;
let frame = 0;
let gameOver = false;
let bossPatternIndex = 0;
let bossPatternTimer = 0;

canvas.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  player.x = e.clientX - rect.left;
  player.y = e.clientY - rect.top;
});

function shoot() {
  if (!player.canShoot) return;
  let bullets = [];
  const bulletSpeed = -9; // 속도 증가
  if (player.powerLevel === 0) {
    bullets.push({x: player.x, y: player.y - 20, dy: bulletSpeed});
  } else if (player.powerLevel === 1) {
    bullets.push({x: player.x - 10, y: player.y - 20, dy: bulletSpeed});
    bullets.push({x: player.x + 10, y: player.y - 20, dy: bulletSpeed});
  } else {
    bullets.push({x: player.x - 10, y: player.y - 20, dy: bulletSpeed});
    bullets.push({x: player.x + 10, y: player.y - 20, dy: bulletSpeed});
    setTimeout(() => {
      player.bullets.push({x: player.x - 10, y: player.y - 20, dy: bulletSpeed});
      player.bullets.push({x: player.x + 10, y: player.y - 20, dy: bulletSpeed});
    }, 100);
  }
  player.bullets.push(...bullets);
  player.canShoot = false;
  setTimeout(() => (player.canShoot = true), 150);
}

function spawnEnemy() {
  enemies.push({
    x: Math.random() * (canvas.width - 20) + 10,
    y: -20,
    hp: Math.random() < 0.5 ? 1 : 2,
    cooldown: 0
  });
}

function spawnPowerup() {
  if (Math.random() < 0.3) { // 30% 확률 생명 회복
    powerups.push({x: Math.random() * (canvas.width - 20) + 10, y: -10, type: 'life'});
  } else {
    powerups.push({x: Math.random() * (canvas.width - 20) + 10, y: -10, type: 'power'});
  }
}

function drawTriangle(x, y, size, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x, y - size);
  ctx.lineTo(x - size, y + size);
  ctx.lineTo(x + size, y + size);
  ctx.closePath();
  ctx.fill();
}

function loop() {
  if (gameOver) return;

  frame++;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 적 출현
  if (frame - lastSpawn > spawnInterval) {
    spawnEnemy();
    lastSpawn = frame;
  }

  // 파워업 출현
  if (Math.random() < 0.0025) spawnPowerup(); // 25% 증가

  // 플레이어 총알
  player.bullets.forEach((b, i) => {
    b.y += b.dy;
    ctx.fillStyle = "cyan";
    ctx.fillRect(b.x - 2, b.y - 10, 4, 10);
    if (b.y < 0) player.bullets.splice(i, 1);
  });

  // 적
  enemies.forEach((e, i) => {
    e.y += 2;
    drawTriangle(e.x, e.y, 15, "red");

    if (e.cooldown <= 0 && Math.random() < 0.02) {
      for (let a = 0; a < enemyBulletCount; a++) {
        const angle = (a / enemyBulletCount) * Math.PI * 2;
        enemyBullets.push({
          x: e.x,
          y: e.y,
          dx: Math.cos(angle) * 2,
          dy: Math.sin(angle) * 2,
          size: enemyBulletSize
        });
      }
      e.cooldown = 60;
    } else e.cooldown--;

    // 피격 판정
    player.bullets.forEach((b, j) => {
      if (Math.abs(b.x - e.x) < 10 && Math.abs(b.y - e.y) < 10) {
        e.hp--;
        player.bullets.splice(j, 1);
        if (e.hp <= 0) {
          enemies.splice(i, 1);
          score += 100;
        }
      }
    });

    if (e.y > canvas.height + 20) enemies.splice(i, 1);
  });

  // 적 총알
  enemyBullets.forEach((b, i) => {
    b.x += b.dx;
    b.y += b.dy;
    ctx.fillStyle = "orange";
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();
    if (b.y > canvas.height || b.y < 0) enemyBullets.splice(i, 1);
    if (Math.abs(b.x - player.x) < b.size + player.size && Math.abs(b.y - player.y) < b.size + player.size) {
      enemyBullets.splice(i, 1);
      player.hp--;
      updateHearts();
      if (player.hp <= 0) endGame();
    }
  });

  // 파워업
  powerups.forEach((p, i) => {
    p.y += 2;
    if (p.type === 'power') ctx.fillStyle = "lime";
    else ctx.fillStyle = "green";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
    ctx.fill();
    if (Math.abs(p.x - player.x) < 15 && Math.abs(p.y - player.y) < 15) {
      powerups.splice(i, 1);
      if (p.type === 'power') player.powerLevel = Math.min(player.powerLevel + 1, 2);
      else player.hp = Math.min(player.hp + 1, 3);
      updateHearts();
    }
  });

  // 플레이어
  drawTriangle(player.x, player.y, player.size, "white");

  // 점수 / 보스 관리
  if (!boss && score >= bossSpawnScore) spawnBoss();

  if (boss) updateBoss();

  document.getElementById("score").innerText = "Score: " + score;

  requestAnimationFrame(loop);
}

function spawnBoss() {
  boss = {x: canvas.width / 2, y: 80, hp: bossHpBase};
  bossPatternTimer = 0;
  bossPatternIndex = 0;
}

function updateBoss() {
  bossPatternTimer++;
  if (bossPatternTimer % 300 === 0) bossPatternIndex = (bossPatternIndex + 1) % 3; // 5초마다 패턴 변경

  ctx.fillStyle = "purple";
  ctx.fillRect(boss.x - 40, boss.y - 20, 80, 40);
  ctx.fillStyle = "red";
  ctx.fillRect(boss.x - 40, boss.y - 30, (boss.hp / bossHpBase) * 80, 5);

  if (bossPatternIndex === 0) shootBossPattern1();
  if (bossPatternIndex === 1) shootBossPattern2();
  if (bossPatternIndex === 2) shootBossPattern3();

  // 플레이어 총알 충돌
  player.bullets.forEach((b, j) => {
    if (Math.abs(b.x - boss.x) < 40 && Math.abs(b.y - boss.y) < 40) {
      boss.hp -= 10;
      player.bullets.splice(j, 1);
      if (boss.hp <= 0) {
        score += 2000;
        boss = null;
        bossSpawnScore += 10000;
        bossHpBase *= 2;
        spawnInterval *= 0.9;
        enemyBulletCount *= 1.1;
      }
    }
  });
}

function shootBossPattern1() { // 원형
  if (frame % 30 === 0) {
    for (let i = 0; i < 16; i++) {
      const angle = (i / 16) * Math.PI * 2;
      enemyBullets.push({x: boss.x, y: boss.y, dx: Math.cos(angle) * 3, dy: Math.sin(angle) * 3, size: enemyBulletSize*1.5});
    }
  }
}
function shootBossPattern2() { // 나선
  if (frame % 5 === 0) {
    const angle = (frame / 5) * 0.2;
    for (let i = 0; i < 8; i++) {
      const a = angle + (i/8)*Math.PI*2;
      enemyBullets.push({x: boss.x, y: boss.y, dx: Math.cos(a)*3, dy: Math.sin(a)*3, size: enemyBulletSize*1.5});
    }
  }
}
function shootBossPattern3() { // 팬텀 발사
  if (frame % 15 === 0) {
    for (let i = -1; i <=1; i+=2) {
      enemyBullets.push({x: boss.x, y: boss.y, dx: i*2, dy:4, size: enemyBulletSize*1.5});
    }
  }
}

function updateHearts() {
  const heartDisplay = "❤️".repeat(player.hp) + "🖤".repeat(3 - player.hp);
  document.getElementById("lives").innerText = heartDisplay;
}

function endGame() {
  gameOver = true;
  alert("게임 오버! 점수: " + score);
}

setInterval(shoot, 200);
loop();
</script>
</body>
</html>
