<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>비행기 탄막 게임</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(#000, #010a10);
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: linear-gradient(to bottom, #002040, #000);
    border: 2px solid #333;
    touch-action: none;
  }
  #ui {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-family: monospace;
    text-align: center;
  }
  #restart {
    display: none;
    margin-top: 10px;
    padding: 5px 10px;
    background: #333;
    color: white;
    border: 1px solid #888;
    cursor: pointer;
  }
</style>
</head>
<body>
<div id="ui">
  <div id="score">점수: 0</div>
  <div id="hp">체력: 3</div>
  <div id="highscore" style="display:none"></div>
  <button id="restart">다시하기</button>
</div>
<canvas id="game" width="460" height="700"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const hpDisplay = document.getElementById('hp');
const highscoreDisplay = document.getElementById('highscore');
const restartBtn = document.getElementById('restart');

let player = { x: 230, y: 600, w: 30, h: 30, hp: 3, bullets: [], power: 1 };
let enemies = [];
let enemyBullets = [];
let powerups = [];
let boss = null;
let score = 0;
let gameOver = false;
let lastEnemySpawn = 0;
let lastPowerupSpawn = 0;
let mouse = {x: 230, y: 600};
let lastPlayerShot = 0;

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});

canvas.addEventListener('touchmove', e => {
  const rect = canvas.getBoundingClientRect();
  const t = e.touches[0];
  mouse.x = t.clientX - rect.left;
  mouse.y = t.clientY - rect.top;
});

restartBtn.onclick = () => {
  location.reload();
};

function drawRect(x, y, w, h, c) {
  ctx.fillStyle = c;
  ctx.fillRect(x - w/2, y - h/2, w, h);
}

function spawnEnemy() {
  let x = Math.random() * (canvas.width - 40) + 20;
  enemies.push({
    x, y: -20, w: 30, h: 30, hp: 1 + Math.floor(Math.random() * 2), cooldown: 0
  });
}

function spawnPowerup() {
  let x = Math.random() * (canvas.width - 40) + 20;
  powerups.push({ x, y: -20, w: 20, h: 20 });
}

function spawnBoss() {
  boss = { x: canvas.width / 2, y: 80, w: 100, h: 60, hp: 100, patternTime: 0 };
}

function shootEnemyBullet(e) {
  const count = 4; // 기존보다 1/3 수준으로 감소
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 / count) * i;
    enemyBullets.push({
      x: e.x, y: e.y, dx: Math.cos(angle) * 2.5, dy: Math.sin(angle) * 2.5
    });
  }
}

function shootDeathBullets(e) {
  const count = 3; // 사망 시 적은 탄막 유지
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 / count) * i;
    enemyBullets.push({
      x: e.x, y: e.y, dx: Math.cos(angle) * 1.5, dy: Math.sin(angle) * 1.5
    });
  }
}

function shootPlayer() {
  for (let i = 0; i < player.power; i++) {
    const offset = (i - (player.power - 1)/2) * 10;
    player.bullets.push({x: player.x + offset, y: player.y - 20, dy: -7});
  }
}

function update() {
  if (gameOver) return;

  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 플레이어 즉시 마우스 위치로 이동
  player.x = mouse.x;
  player.y = mouse.y;

  // 적기 스폰 빈도 줄임 (기존보다 2/3 정도)
  if (!boss && Date.now() - lastEnemySpawn > 1200) {
    spawnEnemy();
    lastEnemySpawn = Date.now();
  }

  // 파워업 스폰
  if (!boss && Date.now() - lastPowerupSpawn > 10000) {
    spawnPowerup();
    lastPowerupSpawn = Date.now();
  }

  // 플레이어 총알 발사
  if (Date.now() - lastPlayerShot > 150) {
    shootPlayer();
    lastPlayerShot = Date.now();
  }

  // 플레이어 총알 이동
  player.bullets.forEach(b=>b.y += b.dy);
  player.bullets = player.bullets.filter(b=>b.y>-10);

  // 적 이동 및 탄 발사
  enemies.forEach(e=>{
    e.y += 1;
    e.cooldown -= 1;
    if (e.cooldown <= 0) {
      shootEnemyBullet(e);
      e.cooldown = 90; // 발사 주기
    }
  });

  // 적 총알 이동
  enemyBullets.forEach(b=>{
    b.x += b.dx;
    b.y += b.dy;
  });

  // 파워업 이동
  powerups.forEach(p=>p.y += 2);

  // 충돌 체크
  enemies.forEach((e,ei)=>{
    player.bullets.forEach((b,bi)=>{
      if (Math.abs(e.x-b.x)<15 && Math.abs(e.y-b.y)<15){
        e.hp--;
        player.bullets.splice(bi,1);
        if (e.hp<=0){
          shootDeathBullets(e);
          enemies.splice(ei,1);
          score += 100;
          if (score>=10000 && !boss) {
            enemies = [];
            spawnBoss();
          }
        }
      }
    });
  });

  enemyBullets.forEach((b,bi)=>{
    if (Math.abs(b.x-player.x)<15 && Math.abs(b.y-player.y)<15){
      enemyBullets.splice(bi,1);
      player.hp--;
      if (player.hp<=0){
        endGame();
      }
    }
  });

  powerups.forEach((p,pi)=>{
    if (Math.abs(p.x-player.x)<20 && Math.abs(p.y-player.y)<20){
      player.power++;
      if (player.power>5) player.power=5;
      powerups.splice(pi,1);
    }
  });

  // 보스 패턴
  if (boss){
    boss.patternTime++;
    if (boss.patternTime%60===0){
      const pattern = boss.patternTime%180===0?1: boss.patternTime%120===0?2:3;
      shootBossPattern(pattern);
    }
  }

  // draw
  drawRect(player.x, player.y, player.w, player.h, "#0f0");
  player.bullets.forEach(b=>drawRect(b.x,b.y,4,10,"#ff0"));
  enemies.forEach(e=>drawRect(e.x,e.y,e.w,e.h,"#f00"));
  enemyBullets.forEach(b=>drawRect(b.x,b.y,4,4,"#0ff"));
  powerups.forEach(p=>drawRect(p.x,p.y,p.w,p.h,"#0f8"));
  if (boss) drawRect(boss.x,boss.y,boss.w,boss.h,"#f0f");

  scoreDisplay.textContent = `점수: ${score}`;
  hpDisplay.textContent = `체력: ${player.hp}`;

  requestAnimationFrame(update);
}

function shootBossPattern(p){
  if (!boss) return;
  const bx=boss.x, by=boss.y+20;
  if (p===1){
    for(let i=0;i<20;i++){
      const a=Math.PI*2*i/20;
      enemyBullets.push({x:bx,y:by,dx:Math.cos(a)*2,dy:Math.sin(a)*2});
    }
  } else if (p===2){
    for(let i=0;i<10;i++){
      const a=Math.PI*i/10;
      enemyBullets.push({x:bx+Math.cos(a)*80,y:by,dx:0,dy:3});
    }
  } else {
    for(let i=0;i<30;i++){
      const a=Math.PI*2*i/30;
      enemyBullets.push({x:bx,y:by,dx:Math.cos(a)*1.5,dy:Math.sin(a)*3});
    }
  }
}

function endGame(){
  gameOver=true;
  const high = localStorage.getItem("hiscore")||0;
  if (score>high) localStorage.setItem("hiscore",score);
  highscoreDisplay.style.display="block";
  highscoreDisplay.textContent=`하이스코어: ${Math.max(score,high)}점`;
  restartBtn.style.display="block";
}

update();
</script>
</body>
</html>
